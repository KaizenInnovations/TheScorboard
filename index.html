<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KAIZEN x FF - Command Center</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
        }
        #dashboard-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        canvas {
            background-color: #111827;
            cursor: default;
        }
        #canvas-input {
            position: absolute;
            z-index: 10;
            display: none;
            background: transparent;
            border: 2px solid #F59E0B;
            color: white;
            text-align: center;
            font-family: 'Roboto', sans-serif;
            font-weight: 900;
            outline: none;
            border-radius: 8px;
            padding: 0;
            -moz-appearance: textfield;
        }
        #canvas-input::-webkit-outer-spin-button,
        #canvas-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="dashboard-container">
        <canvas id="dashboardCanvas"></canvas>
        <input type="number" id="canvas-input" />
    </div>

    <script>
        const canvas = document.getElementById('dashboardCanvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('canvas-input');

        let state = {
            foundation_monthly: 0, foundation_pif3: 0, foundation_pif6: 0,
            accelerator_monthly: 0, accelerator_pif3: 0, accelerator_pif6: 0,
            vip_monthly: 0, vip_pif3: 0, vip_pif6: 0,
            online_coaching: 0, livestream: 0, onlyfans: 0
        };

        const config = {
            colors: { kaizen: '#00BF63', ff: '#FF69B4', accent: '#F59E0B', text: '#E5E7EB', textMuted: '#9CA3AF' },
            prices: {
                foundation_monthly: 520, foundation_pif3: 520 * 3 * 0.90, foundation_pif6: 520 * 6 * 0.85,
                accelerator_monthly: 720, accelerator_pif3: 720 * 3 * 0.90, accelerator_pif6: 720 * 6 * 0.85,
                vip_monthly: 880, vip_pif3: 880 * 3 * 0.90, vip_pif6: 880 * 6 * 0.85,
                online_coaching: 15, livestream: 20, onlyfans: 10
            },
            hours: {
                foundation_monthly: 8, foundation_pif3: 8, foundation_pif6: 8,
                accelerator_monthly: 12, accelerator_pif3: 12, accelerator_pif6: 12,
                vip_monthly: 16, vip_pif3: 16, vip_pif6: 16,
                online_coaching: 10/60, 
                livestream: 0, // Fixed hours are calculated below
                onlyfans: 0 // Fixed hours are calculated below
            }
        };

        let interactiveElements = {};
        let mousePos = { x: -1, y: -1 };
        let activeInput = null;

        function drawRoundedRect(x, y, w, h, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            ctx.clearRect(0, 0, width, height);
            interactiveElements = {};

            const isMobile = width < 1024;
            const padding = Math.max(20, width * 0.03);
            let currentY = padding * 1.5;

            // Header
            ctx.fillStyle = config.colors.accent;
            ctx.font = `400 ${isMobile ? '32px' : '48px'} Anton`;
            ctx.textAlign = 'center';
            ctx.fillText('KAIZEN x FF // COMMAND CENTER', width / 2, currentY);
            currentY += isMobile ? 40 : 70;
            
            const mainWidth = width - (padding * 2);
            const totalsWidth = isMobile ? mainWidth : mainWidth * 0.33;
            const inputsWidth = isMobile ? mainWidth : mainWidth * 0.62;
            const startX = padding;
            
            let totalsHeight = drawTotals(isMobile ? startX : startX + inputsWidth + (mainWidth * 0.05), currentY, totalsWidth);
            let inputsY = currentY;
            if (isMobile) inputsY += totalsHeight + 30;

            const cardWidth = isMobile ? inputsWidth : (inputsWidth - 20) / 3;
            
            let cardX = startX;
            drawKaizenCard(cardX, inputsY, cardWidth, 'FOUNDATION', 'foundation');
            cardX += cardWidth + 10;
            drawKaizenCard(cardX, inputsY, cardWidth, 'ACCELERATOR', 'accelerator');
            cardX += cardWidth + 10;
            drawKaizenCard(cardX, inputsY, cardWidth, 'VIP', 'vip');
            
            inputsY += 320;

            drawInputGroup(startX, inputsY, inputsWidth, 'FUCKING FITNESS', config.colors.ff, [
                { id: 'online_coaching', label: 'Online Coaching Pkg' },
                { id: 'livestream', label: 'Livestream Addon' },
                { id: 'onlyfans', label: 'Onlyfans Sub' },
            ]);
        }

        function drawTotals(x, y, w) {
            let totalClients = 0, monthlyRevenue = 0, annualRevenue = 0, totalHours = 0;
            for(const id in state) {
                const count = state[id]; 
                totalClients += count; 
                totalHours += count * config.hours[id];
                if (id.includes('_monthly') || id.includes('online') || id.includes('livestream') || id.includes('onlyfans')) {
                    monthlyRevenue += count * config.prices[id]; annualRevenue += count * config.prices[id] * 12;
                } else if (id.includes('_pif3')) {
                    monthlyRevenue += count * (config.prices[id] / 3); annualRevenue += count * config.prices[id];
                } else if (id.includes('_pif6')) {
                    monthlyRevenue += count * (config.prices[id] / 6); annualRevenue += count * config.prices[id];
                }
            }

            if (state.livestream > 0) totalHours += 5;
            if (state.onlyfans > 0) totalHours += 5;

            const itemHeight = 100, headerHeight = 70, totalHeight = headerHeight + (4 * itemHeight);
            drawRoundedRect(x, y, w, totalHeight, 16, '#1F2937');
            ctx.fillStyle = config.colors.text; ctx.font = '700 20px Roboto'; ctx.textAlign = 'center';
            ctx.fillText('MISSION TOTALS', x + w / 2, y + 40);
            let itemY = y + headerHeight;
            drawTotalItem(x, itemY, w, 'TOTAL ROSTER', totalClients.toFixed(0));
            drawTotalItem(x, itemY + itemHeight, w, 'PROJECTED MONTHLY', `$${monthlyRevenue.toFixed(2)}`);
            drawTotalItem(x, itemY + itemHeight*2, w, 'PROJECTED ANNUAL', `$${annualRevenue.toFixed(2)}`);
            drawTotalItem(x, itemY + itemHeight*3, w, 'VARIABLE HOURS / MO', totalHours.toFixed(1));
            return totalHeight;
        }
        
        function drawTotalItem(x, y, w, label, value) {
            ctx.fillStyle = config.colors.accent; ctx.font = '700 16px Roboto';
            ctx.fillText(label, x + w/2, y + 35);
            ctx.fillStyle = '#FFFFFF'; ctx.font = `900 ${value.length > 8 ? '32px' : '40px'} Roboto`;
            ctx.fillText(value, x + w/2, y + 70);
        }

        function drawKaizenCard(x, y, w, title, baseId) {
            const h = 290;
            drawRoundedRect(x, y, w, h, 16, '#1F2937');
            ctx.fillStyle = config.colors.kaizen; ctx.font = '900 22px Roboto'; ctx.textAlign = 'center';
            ctx.fillText(title, x + w / 2, y + 35);
            drawInputItem(x + 15, y + 70, w - 30, `${baseId}_monthly`, 'Monthly');
            drawInputItem(x + 15, y + 140, w - 30, `${baseId}_pif3`, 'PIF 3-Mo');
            drawInputItem(x + 15, y + 210, w - 30, `${baseId}_pif6`, 'PIF 6-Mo');
        }
        
        function drawInputGroup(x, y, w, title, color, items) {
            const h = 70 + (items.length * 70);
            drawRoundedRect(x, y, w, h, 16, '#1F2937');
            ctx.fillStyle = color; ctx.font = '900 22px Roboto'; ctx.textAlign = 'center';
            ctx.fillText(title, x + w / 2, y + 40);
            let itemY = y + 70;
            items.forEach(item => {
                drawInputItem(x + 15, itemY, w - 30, item.id, item.label);
                itemY += 70;
            });
        }

        function drawInputItem(x, y, w, id, label) {
            ctx.fillStyle = config.colors.textMuted; ctx.font = '700 16px Roboto';
            ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y + 20);

            const btnSize = 38, inputW = 70, inputH = 38;
            const plusX = x + w - btnSize;
            const numX = plusX - inputW - 12;
            const minusX = numX - btnSize - 12;

            const isHoverMinus = mousePos.x >= minusX && mousePos.x <= minusX + btnSize && mousePos.y >= y && mousePos.y <= y + btnSize;
            const isHoverPlus = mousePos.x >= plusX && mousePos.x <= plusX + btnSize && mousePos.y >= y && mousePos.y <= y + btnSize;
            const isHoverNum = mousePos.x >= numX && mousePos.x <= numX + inputW && mousePos.y >= y && mousePos.y <= y + inputH;
            
            drawRoundedRect(minusX, y, btnSize, btnSize, 19, isHoverMinus ? config.colors.accent : '#4B5563');
            ctx.fillStyle = '#FFF'; ctx.font = '900 22px Roboto'; ctx.textAlign = 'center';
            ctx.fillText('-', minusX + btnSize / 2, y + 21);
            interactiveElements[`${id}_minus`] = { x: minusX, y, w: btnSize, h: btnSize, action: () => { if(state[id] > 0) state[id]--; draw(); } };

            if (activeInput !== id) {
                drawRoundedRect(numX, y, inputW, inputH, 8, isHoverNum ? '#374151' : '#111827');
                ctx.fillStyle = '#FFF'; ctx.font = '900 20px Roboto';
                ctx.fillText(state[id], numX + inputW / 2, y + 20);
            }
            interactiveElements[`${id}_input`] = { x: numX, y, w: inputW, h: inputH, action: () => showInput(id, numX, y, inputW, inputH) };
            
            drawRoundedRect(plusX, y, btnSize, btnSize, 19, isHoverPlus ? config.colors.accent : '#4B5563');
            ctx.fillStyle = '#FFF'; ctx.font = '900 22px Roboto';
            ctx.fillText('+', plusX + btnSize / 2, y + 21);
            interactiveElements[`${id}_plus`] = { x: plusX, y, w: btnSize, h: btnSize, action: () => { state[id]++; draw(); } };
        }

        function showInput(id, x, y, w, h) {
            activeInput = id;
            const rect = canvas.getBoundingClientRect();
            
            textInput.style.display = 'block';
            textInput.style.left = `${rect.left + x}px`;
            textInput.style.top = `${rect.top + y}px`;
            textInput.style.width = `${w}px`;
            textInput.style.height = `${h}px`;
            textInput.style.fontSize = `${20}px`;
            
            textInput.value = state[id];
            setTimeout(() => textInput.focus(), 0);
            
            textInput.oninput = () => {
                let val = parseInt(textInput.value);
                if (isNaN(val) || val < 0) val = 0;
                state[id] = val;
                // No redraw here, let the input field be the source of truth
            };
            textInput.onblur = () => {
                textInput.style.display = 'none';
                activeInput = null;
                draw(); // Redraw with the final number when done
            };
            draw(); // Redraw to hide the canvas number
        }

        function handleEvents(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            if (event.type === 'mousemove') {
                mousePos = { x, y };
                let isHovering = false;
                for (const key in interactiveElements) {
                    const el = interactiveElements[key];
                    if (x >= el.x && x <= el.x + el.w && y >= el.y && y <= el.y + el.h) {
                        isHovering = true;
                        break;
                    }
                }
                canvas.style.cursor = isHovering ? 'pointer' : 'default';
                draw();
            }

            if (event.type === 'mousedown') {
                if (activeInput) {
                    textInput.blur();
                    return;
                }
                for (const key in interactiveElements) {
                    const el = interactiveElements[key];
                    if (x >= el.x && x <= el.x + el.w && y >= el.y && y <= el.y + el.h) {
                        event.preventDefault();
                        el.action();
                        break;
                    }
                }
            }
        }
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            ctx.scale(dpr, dpr);
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousedown', handleEvents);
        canvas.addEventListener('mousemove', handleEvents);
        resizeCanvas();
    </script>
</body>
</html>

