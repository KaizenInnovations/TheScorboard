<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boutique Business Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            background-color: #FEFBF6; /* Soft off-white */
        }
        #dashboard-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        canvas {
            cursor: default;
        }
        #canvas-input {
            position: absolute;
            z-index: 10;
            display: none;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #D6AD60; /* Gold accent */
            color: #333;
            text-align: center;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            outline: none;
            border-radius: 8px;
            padding: 0;
            -moz-appearance: textfield;
        }
        #canvas-input::-webkit-outer-spin-button,
        #canvas-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body>

    <div id="dashboard-container">
        <canvas id="dashboardCanvas"></canvas>
        <input type="number" id="canvas-input" />
    </div>

    <script>
        const canvas = document.getElementById('dashboardCanvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('canvas-input');

        let state = {
            foundation_monthly: 0, foundation_pif3: 0, foundation_pif6: 0,
            accelerator_monthly: 0, accelerator_pif3: 0, accelerator_pif6: 0,
            vip_monthly: 0, vip_pif3: 0, vip_pif6: 0,
            online_coaching: 0, livestream: 0, onlyfans: 0
        };

        const config = {
            colors: { 
                background: '#FEFBF6',
                card: '#FFFFFF',
                primary: '#E0BBE4', // Lavender
                secondary: '#FFDFD3', // Soft Pink
                accent: '#D6AD60',   // Gold
                text: '#333333',
                textMuted: '#A9A9A9'
            },
            prices: {
                foundation_monthly: 520, foundation_pif3: 520 * 3 * 0.90, foundation_pif6: 520 * 6 * 0.85,
                accelerator_monthly: 720, accelerator_pif3: 720 * 3 * 0.90, accelerator_pif6: 720 * 6 * 0.85,
                vip_monthly: 880, vip_pif3: 880 * 3 * 0.90, vip_pif6: 880 * 6 * 0.85,
                online_coaching: 15, livestream: 20, onlyfans: 10
            },
            hours: {
                foundation_monthly: 8, foundation_pif3: 8, foundation_pif6: 8,
                accelerator_monthly: 12, accelerator_pif3: 12, accelerator_pif6: 12,
                vip_monthly: 16, vip_pif3: 16, vip_pif6: 16,
                online_coaching: 10/60, 
                livestream: 0,
                onlyfans: 0
            }
        };

        let interactiveElements = {};
        let mousePos = { x: -1, y: -1 };
        let activeInput = null;
        let lastHoverKey = null;

        function drawRoundedRect(x, y, w, h, r, color, strokeColor = null) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            if (strokeColor) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function draw() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = config.colors.background;
            ctx.fillRect(0, 0, width, height);
            interactiveElements = {};

            const isMobile = width < 1024;
            const padding = Math.max(20, width * 0.04);
            let currentY = padding * 1.5;

            ctx.fillStyle = config.colors.text;
            ctx.font = `700 ${isMobile ? '28px' : '40px'} 'Playfair Display'`;
            ctx.textAlign = 'center';
            ctx.fillText('Boutique Business Dashboard', width / 2, currentY);
            currentY += isMobile ? 40 : 70;
            
            const mainWidth = width - (padding * 2);
            const totalsWidth = isMobile ? mainWidth : mainWidth * 0.33;
            const inputsWidth = isMobile ? mainWidth : mainWidth * 0.62;
            const startX = padding;
            
            let totalsHeight = drawTotals(isMobile ? startX : startX + inputsWidth + (mainWidth * 0.05), currentY, totalsWidth);
            let inputsY = currentY;
            if (isMobile) inputsY += totalsHeight + 30;

            const cardWidth = isMobile ? inputsWidth : (inputsWidth - 20) / 3;
            
            let cardX = startX;
            drawKaizenCard(cardX, inputsY, cardWidth, 'FOUNDATION', config.colors.primary);
            cardX += cardWidth + 10;
            drawKaizenCard(cardX, inputsY, cardWidth, 'ACCELERATOR', config.colors.secondary);
            cardX += cardWidth + 10;
            drawKaizenCard(cardX, inputsY, cardWidth, 'VIP', config.colors.accent);
            
            inputsY += 320;

            drawInputGroup(startX, inputsY, inputsWidth, 'ONLINE VENTURES', config.colors.secondary, [
                { id: 'online_coaching', label: 'Online Coaching' },
                { id: 'livestream', label: 'Livestream Addon' },
                { id: 'onlyfans', label: 'Subscription' },
            ]);
        }

        function drawTotals(x, y, w) {
            let totalClients = 0, monthlyRevenue = 0, annualRevenue = 0, totalHours = 0;
            for(const id in state) {
                const count = state[id]; totalClients += count; totalHours += count * config.hours[id];
                if (id.includes('_monthly') || id.includes('online') || id.includes('livestream') || id.includes('onlyfans')) {
                    monthlyRevenue += count * config.prices[id]; annualRevenue += count * config.prices[id] * 12;
                } else if (id.includes('_pif3')) {
                    monthlyRevenue += count * (config.prices[id] / 3); annualRevenue += count * config.prices[id];
                } else if (id.includes('_pif6')) {
                    monthlyRevenue += count * (config.prices[id] / 6); annualRevenue += count * config.prices[id];
                }
            }
            if (state.livestream > 0) totalHours += 5;
            if (state.onlyfans > 0) totalHours += 5;

            const itemHeight = 100, headerHeight = 70, totalHeight = headerHeight + (4 * itemHeight);
            drawRoundedRect(x, y, w, totalHeight, 20, config.colors.card, config.colors.primary + '33');
            ctx.fillStyle = config.colors.text; ctx.font = `700 20px 'Playfair Display'`; ctx.textAlign = 'center';
            ctx.fillText('Financial Snapshot', x + w / 2, y + 40);
            
            let itemY = y + headerHeight;
            drawTotalItem(x, itemY, w, 'TOTAL CLIENTS & SUBS', totalClients.toFixed(0));
            drawTotalItem(x, itemY + itemHeight, w, 'PROJECTED MONTHLY REVENUE', `$${monthlyRevenue.toFixed(2)}`);
            drawTotalItem(x, itemY + itemHeight*2, w, 'PROJECTED ANNUAL REVENUE', `$${annualRevenue.toFixed(2)}`);
            drawTotalItem(x, itemY + itemHeight*3, w, 'ESTIMATED HOURS / MO', totalHours.toFixed(1));
            return totalHeight;
        }
        
        function drawTotalItem(x, y, w, label, value) {
            ctx.fillStyle = config.colors.textMuted; ctx.font = '600 14px Poppins';
            ctx.fillText(label, x + w/2, y + 35);
            ctx.fillStyle = config.colors.text; ctx.font = `700 ${value.length > 8 ? '28px' : '36px'} Poppins`;
            ctx.fillText(value, x + w/2, y + 70);
        }

        function drawKaizenCard(x, y, w, title, color) {
            const h = 290;
            drawRoundedRect(x, y, w, h, 20, config.colors.card, color + '33');
            ctx.fillStyle = color; ctx.font = `700 22px 'Playfair Display'`; ctx.textAlign = 'center';
            ctx.fillText(title, x + w / 2, y + 35);
            drawInputItem(x + 15, y + 70, w - 30, `${title.toLowerCase()}_monthly`, 'Monthly');
            drawInputItem(x + 15, y + 140, w - 30, `${title.toLowerCase()}_pif3`, 'PIF 3-Mo');
            drawInputItem(x + 15, y + 210, w - 30, `${title.toLowerCase()}_pif6`, 'PIF 6-Mo');
        }
        
        function drawInputGroup(x, y, w, title, color, items) {
            const h = 70 + (items.length * 70);
            drawRoundedRect(x, y, w, h, 20, config.colors.card, color + '33');
            ctx.fillStyle = color; ctx.font = `700 22px 'Playfair Display'`; ctx.textAlign = 'center';
            ctx.fillText(title, x + w / 2, y + 40);
            let itemY = y + 70;
            items.forEach(item => {
                drawInputItem(x + 15, itemY, w - 30, item.id, item.label);
                itemY += 70;
            });
        }

        function drawInputItem(x, y, w, id, label) {
            ctx.fillStyle = config.colors.text; ctx.font = '600 16px Poppins';
            ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y + 20);
            const btnSize = 38, inputW = 70, inputH = 38;
            const plusX = x + w - btnSize;
            const numX = plusX - inputW - 12;
            const minusX = numX - btnSize - 12;
            const isHoverMinus = mousePos.x >= minusX && mousePos.x <= minusX + btnSize && mousePos.y >= y && mousePos.y <= y + btnSize;
            const isHoverPlus = mousePos.x >= plusX && mousePos.x <= plusX + btnSize && mousePos.y >= y && mousePos.y <= y + btnSize;
            const isHoverNum = mousePos.x >= numX && mousePos.x <= numX + inputW && mousePos.y >= y && mousePos.y <= y + inputH;
            
            drawRoundedRect(minusX, y, btnSize, btnSize, 19, isHoverMinus ? config.colors.primary : '#F3F4F6');
            ctx.fillStyle = isHoverMinus ? '#FFF' : config.colors.text; ctx.font = '700 22px Poppins'; ctx.textAlign = 'center';
            ctx.fillText('-', minusX + btnSize / 2, y + 21);
            interactiveElements[`${id}_minus`] = { x: minusX, y, w: btnSize, h: btnSize, action: () => { if(state[id] > 0) state[id]--; draw(); } };
            
            if (activeInput !== id) {
                drawRoundedRect(numX, y, inputW, inputH, 8, config.colors.background, isHoverNum ? config.colors.accent : config.colors.background);
                ctx.fillStyle = config.colors.text; ctx.font = '700 20px Poppins';
                ctx.fillText(state[id], numX + inputW / 2, y + 20);
            }
            interactiveElements[`${id}_input`] = { x: numX, y, w: inputW, h: inputH, action: () => showInput(id, numX, y, inputW, inputH) };
            
            drawRoundedRect(plusX, y, btnSize, btnSize, 19, isHoverPlus ? config.colors.primary : '#F3F4F6');
            ctx.fillStyle = isHoverPlus ? '#FFF' : config.colors.text; ctx.font = '700 22px Poppins';
            ctx.fillText('+', plusX + btnSize / 2, y + 21);
            interactiveElements[`${id}_plus`] = { x: plusX, y, w: btnSize, h: btnSize, action: () => { state[id]++; draw(); } };
        }

        function showInput(id, x, y, w, h) {
            activeInput = id;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            textInput.style.display = 'block';
            textInput.style.left = `${rect.left + x / dpr}px`;
            textInput.style.top = `${rect.top + y / dpr}px`;
            textInput.style.width = `${w / dpr}px`;
            textInput.style.height = `${h / dpr}px`;
            textInput.style.fontSize = `${20 / dpr}px`;
            textInput.value = state[id];
            setTimeout(() => textInput.focus(), 0);
            textInput.oninput = () => {
                let val = parseInt(textInput.value);
                if (isNaN(val) || val < 0) val = 0;
                state[id] = val;
            };
            textInput.onblur = () => {
                textInput.style.display = 'none';
                activeInput = null;
                draw();
            };
            draw();
        }

        function handleEvents(event) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * dpr;
            const y = (event.clientY - rect.top) * dpr;
            
            if (event.type === 'mousemove') {
                mousePos = { x, y };
                let currentHoverKey = null;
                for (const key in interactiveElements) {
                    const el = interactiveElements[key];
                    if (x >= el.x && x <= el.x + el.w && y >= el.y && y <= el.y + el.h) {
                        currentHoverKey = key;
                        break;
                    }
                }
                canvas.style.cursor = currentHoverKey ? 'pointer' : 'default';
                if (lastHoverKey !== currentHoverKey) {
                    lastHoverKey = currentHoverKey;
                    draw();
                }
            }

            if (event.type === 'mousedown') {
                if (activeInput) textInput.blur();
                for (const key in interactiveElements) {
                    const el = interactiveElements[key];
                    if (x >= el.x && x <= el.x + el.w && y >= el.y && y <= el.y + el.h) {
                        event.preventDefault();
                        el.action();
                        break;
                    }
                }
            }
        }
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        document.fonts.ready.then(() => {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleEvents);
            canvas.addEventListener('mousemove', handleEvents);
            resizeCanvas();
        });
    </script>
</body>
</html>
